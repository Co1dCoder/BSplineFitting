#include "spline_curve_fitting.h"


void SplineCurveFitting::initControlPoint(const vector<CVector2>& points, 
									  vector<CVector2>& controlPs,
									  int controlNum)
{
	// compute the initial 12 control points
	controlPs.clear();
	int perNum = controlNum/4;

	CVector2 v1 = points[0];
	CVector2 v2 = points[0];

	for( unsigned int i = 0 ;i!= points.size(); ++i) {
		CVector2 v = points[i];
		if( v1.x() > v.x() )  v1.m_x = v.x();
		if( v1.y() > v.y() )  v1.m_y = v.y();
		if( v2.x() < v.x() )  v2.m_x = v.x();
		if( v2.y() < v.y() )  v2.m_y = v.y();
	}

	vector<CVector2> rets;
	rets.push_back( v1 );
	rets.push_back( CVector2( v1.x(), v2.y() ) );
	rets.push_back( v2 );
	rets.push_back( CVector2( v2.x(), v1.y() ) );
	rets.push_back( v1 );

	CVector2 dir = ( v2-v1 )*0.5;
	CVector2 cent = v1 + dir;
	for( int i = 0; i < 4; i++ )
	{
		CVector2 p1 = rets[i];
		p1 =  cent + (p1-cent)*1.2f;
		CVector2 p2 = rets[i+1];
		p2 = cent + (p2 -cent) * 1.2f;
		for(int j =0; j < perNum; j++) {
			controlPs.push_back(  p1 + (p2-p1) * j/7.0f );
		}
	}

}

double SplineCurveFitting::apply(
						   const vector<CVector2> &points, 
						   CubicBSplineCurve &curve,
						   int controlNum /* = 28 */,
						   int maxIterNum  /*= 30*/,
						   double alpha /* = 0.002*/, 
						   double gama /* = 0.002 */,
						   double eplison /* = 0.0001*/)
{
	controlNum = controlNum/4*4;

	// initialize the cube B-spline
	CubicBSplineCurve* spline = &curve;
	vector<CVector2> controlPs;
	initControlPoint(points, controlPs, controlNum);
	spline->setNewControl( controlPs);

	// update the control point
	// compute P"(t)
	MatrixXd pm = spline->getSIntegralSq();
	MatrixXd sm = spline->getFIntegralSq();
	// end test
	
	// find the foot print, will result in error
	std::vector< std::pair<int,double> > parameters;
	double fsd = spline->findFootPrint( points, parameters);
	int iterNum = 0;
	while( fsd > eplison && iterNum < maxIterNum)
	{
		MatrixXd ehm(2*controlNum, 2*controlNum);
		VectorXd ehv( 2*controlNum);

		// compute h(D)
		for( int i = 0; i< (int)parameters.size(); i++)
		{
// 			if( labels[i] == false )
// 				continue;

			// compute d, rho, Tkv, Nkv
			double kappa = spline->getCurvature( parameters[i] );
			double rho = 10e+6;
			CVector2 neip = spline->getPos( parameters[i]);
			CVector2 Tkv = spline->getTangent( parameters[i]);
			CVector2 Nkv = spline->getNormal( parameters[i]);
			double d =  ( points[i] - neip ).length() ;
			CVector2 Kv(0.0,0.0);
			bool sign = true;
			if( kappa != 0.0f )
			{
				rho = 1/kappa;
				Kv = spline->getCurvCenter( parameters[i] );
				double ddd =  ( Kv - neip ).length() ;
				sign = spline->checkSameSide( Kv, points[i], neip);
			}
	
 			VectorXd coffv = spline->getCoffe( parameters[i]);
			MatrixXd tempcoffm1( controlNum,1);
			for( int ij = 0; ij < controlNum; ij++)
				tempcoffm1(ij,0) = coffv[ij];
			MatrixXd tempcoffm = tempcoffm1 * (tempcoffm1.transpose());

			// update the matrix
			double fxx  = Tkv.x()*Tkv.x();
			double fyy = Tkv.y()*Tkv.y();
			double fxy = Tkv.x()*Tkv.y();

			CVector2 oldp = neip - points[i];

			if( !sign)
			{
				d = -d;
				VectorXd tempv1 = (coffv)* ( d/(d-rho) ) *( fxx*points[i].x() + fxy*points[i].y());
				VectorXd tempv2 = (coffv)* ( d/(d-rho) ) *( fyy*points[i].y() + fxy*points[i].x());
				for(int i2= 0; i2< controlNum; i2++)
				{
					for( int j = 0; j < controlNum; j++)
					{
						double fp = ( d/(d-rho) )*tempcoffm(i2,j);
						ehm(i2,j) += fxx* fp;
						ehm(i2,j+controlNum) += fxy * fp;
						ehm(i2+controlNum,j) += fxy * fp;
						ehm(i2+controlNum,j+controlNum) += fyy *fp;
					}
					ehv[i2] += tempv1[i2];
					ehv[i2+controlNum] += tempv2[i2];
				}
 			}
			fxx  = Nkv.x()*Nkv.x();
			fyy = Nkv.y()*Nkv.y();
			fxy = Nkv.x()*Nkv.y();
			VectorXd tempv1 = (coffv)*( fxx*points[i].x() + fxy*points[i].y());
			VectorXd tempv2 = (coffv)*( fyy*points[i].y() + fxy*points[i].x());
			for( int i2= 0; i2< controlNum; i2++)
			{
				for( int j = 0; j < controlNum; j++)
				{
					double fp = tempcoffm(i2,j); 
					ehm(i2,j) += fxx* fp;
					ehm(i2,j+controlNum) += fxy * fp;
					ehm(i2+controlNum,j) += fxy * fp;
					ehm(i2+controlNum,j+controlNum) += fyy *fp;
				}
				ehv[i2] += tempv1[i2];
				ehv[i2+controlNum] += tempv2[i2];
			}
		}
 

		// check if ehm, ehv right
		//solve the function
		MatrixXd fm = ehm*0.5 + pm*alpha + sm*gama; 
		VectorXd ehv2 = ehv*0.5;
		VectorXd resultxy = fm.jacobiSvd(ComputeThinU | ComputeThinV).solve(ehv2);

		// update the curve
		for( int i = 0; i<controlNum; i++)
			controlPs[i] = CVector2( resultxy[i], resultxy[i+controlNum]);
		spline->setNewControl( controlPs );	
		++ iterNum;

		fsd = spline->findFootPrint( points, parameters );
	}

	return fsd;
}